Software development process is filled with challenges. There are short deadlines, complex solutions to be made, low tolerance with errors and an ever changing environment. Often there is much more that needs to be done than time to accomplish it. Developers are protagonists in this scenario, and usually is up to them to couple with such pressure when implementing their tasks. In this context, some decisions are made to allow the short term development of the project at the cost of its increased maintenance effort in the future. This phenomena is know as Technical Debt \cite{Cunningham1992}. 

The term Technical Debt has became more popular among software engineer practitioners due its communication potential \cite{Spinola2013MTD}. It is a comprehensible metaphor for managers in need to understand what before was explained trough heavy technical language. With the adoption of the metaphor more specific ways to communicate technical debt during the life cycle of a software project was developed (i.e., technical debt types) \cite{Alves2014MTD}\cite{Kruchten2012}. For the software research community the challenge is to better understand the characteristics of each different type of technical debt advancing the state of the art in detection and management of technical debt.

 % In the software engineering community the topic is getting more attention and studies addressing the identification and management of technical debt. \todo{citations here}

Despite the efforts addressing this problem there is still one relatively unexplored aspect of technical debt that is technical debt contained in source code comments. Sometimes, developers knowing that the current implementation is not optimal, write comments alerting the inadequacy of the solution. This kind of technical debt is called self-admitted technical debt. 

Potdar and Shihab \cite{Potdar2014ICSME} developed an approach to identify these comments, and trough manual inspection they were able to mine 62 patterns that effectively identifies self-admitted technical debt. However, their approach does not take in consideration the different types of technical debt, and knowing how to extract specific types of self-technical debt is important. For example, different types of debt can have different priorities, and the effort needed to pay the debt will vary from type to type. Understanding the distribution of self-admitted technical debt will lead to better solutions to manage it.

Our work explore the characteristics of these different types of self-admitted technical debt. We extract source code comments from 5 well commented open source projects that belongs to different application domains, namely Apache Ant, Apache Jmeter, ArgoUml, Columba and JFreeChart. Collecting in total more than 166,756 comments. Then we applied a set of 4 simple filtering heuristics to remove comments that are not likely to contain self-admitted technical debt (e.g., license comments, commented source code, Javadoc comments). Finally, the first author manually analyzed the remainder of the comments classifying them into different types of self-admitted technical debt. 

When classifying the comments we found 5 types of self-admitted technical debt which are: design debt, defect debt, documentation debt, requirement debt and test debt. Analyzing the distribution of the comments we found that the most common type is design debt ranging from 42\% to 84\% of all classified comments. 

This study complements previous work by Potdar and Shihab \cite{Potdar2014ICSME} in self-admitted technical debt by analyzing and quantifying the different types of self-admitted technical debt. We contribute a rich dataset of self-admitted technical making the data used in this study publicly available. To the best of our knowledge, there is not similar data available and we believe that the dataset will encourage future research in the area of self-admitted technical providing the necessary foundation for more advanced techniques as Natural Language Processing.  

The rest of the paper is organized as follows. Section \ref{sec:related_work} presents related work. We describe our approach and how we did the setup of our case study in Section \ref{sec:approach}. Section \ref{sec:results} shows the case study results. The threats to validity are presented in Section \ref{sec:threats_to_validity} and in Section \ref{sec:conclusion} we present our conclusions and future work. 